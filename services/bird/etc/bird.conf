# Auto-generated by the entrypoint script to pass env vars to this config file
include "envvars.conf";

# Formalities
log stderr { info, remote, warning, error, auth, fatal };
protocol device {}
function is_announcable() {
    case net.type {
        NET_IP4: return net ~ [
            44.31.62.0/24,
            44.31.119.0/24,
            23.142.232.0/24
        ];
        NET_IP6: return net ~ [
            2602:faf5::/40
        ];
        else: return false;
    }
}

# Aggregate routes
protocol static aggregate_v4 {
    ipv4;
    route 44.31.62.0/24 unreachable;
    route 44.31.119.0/24 unreachable;
    route 23.142.232.0/24 unreachable;
}
protocol static aggregate_v6 {
    ipv6;
    route 2602:faf5::/40 unreachable;
}

# Import routes from various interfaces
protocol direct {
    ipv4; ipv6;
    interface "nat64";
}

# Kernel interface
filter kernel_export {
    if source = RTS_DEVICE then reject;
    accept;
}
protocol kernel {
    ipv4 { import none; export filter kernel_export; };
    learn; scan time 10; metric 0;
}
protocol kernel {
    ipv6 { import filter {
        if net = ::/0 then accept;
        reject;
    }; export filter kernel_export; };
    learn; scan time 10; metric 0;
}

# Route collectors get an unfiltered view of the routes we import, 
# but we don't need to clutter the kernel routing table with everything, 
# so we can use a "staging" table to store things, and pipe what we need to other tables.
ipv4 table route_pool_v4;
ipv6 table route_pool_v6;
protocol pipe {
    table route_pool_v4; peer table master4;
    import where is_announcable(); export where is_announcable();
}
protocol pipe {
    table route_pool_v6; peer table master6;
    import where is_announcable(); export where is_announcable();
}

# Send all routes to the route collectors
template bgp route_collector {
    multihop;
    ipv4 { table route_pool_v4; import none; export all; add paths; };
    ipv6 { table route_pool_v6; import none; export all; add paths; };
}
protocol bgp bgp_tools from route_collector { 
    local as OWNAS; neighbor 2a0c:2f07:9459::b9 as 212232;
}
protocol bgp nlnog_lg_v4 from route_collector {
    local as OWNAS; source address 23.142.232.1;
    neighbor 212.114.120.72 as 199036;
}
protocol bgp nlnog_lg_v6 from route_collector {
    local as OWNAS; source address 2602:faf5::;
    neighbor 2001:7b8:62b:1:0:d4ff:fe72:7848 as 199036;
}

######################## PEERS ########################

# Vultr
filter vultr_import {
     bgp_path.delete([64512..65534, 4200000000..4294967294]); 
     if (bgp_path.len = 0) then { bgp_path.prepend(20473); }
    #  accept; 
    reject;
}
template bgp tl_vultr {
    local as OWNAS;
    multihop 2; password VULTR_SESSION_PASS;
    graceful restart;
    ipv4 { 
        table route_pool_v4;
        import filter vultr_import;
        export where is_announcable(); 
    };
    ipv6 { 
        table route_pool_v6;
        import filter vultr_import;
        export where is_announcable(); 
    };
}
protocol bgp vultr_v4 from tl_vultr { neighbor 169.254.169.254 as 64515; }
protocol bgp vultr_v6 from tl_vultr { neighbor 2001:19f0:ffff::1 as 64515; }

# Home GW
protocol bgp home {
    local as OWNAS;
    neighbor 2602:faf5::3 as OWNAS;
    graceful restart;
    hold time 30;
    ipv6 {
        import none;
        export filter {
            if is_announcable() then accept;
            if net ~ [
                ::/0,
                64:ff9b::/96
            ] then accept;
            reject;
        };
    };
}